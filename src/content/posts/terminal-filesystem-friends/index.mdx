---
title: The File System & The Terminal
tagline: The draft of what might one day become a fujoweb.dev article
tags:
  - +terminal
  - +tech
  - "+level: beginner++"
created_at: 2024-02-11 18:49:27
status: rough-draft
---

## What's a File System, anyway?

Think of data stored on a disk as a primordial soup of `0`s and `1`s. While all
the information you have saved does exist somewhere on the disk, it cannot be
retrieved without something to give it boundaries and "shape". **The file system
is the part of the operating system in charge of reading and writing "files" out
of this sea of data**[^-1].

<figure>
![TODO](./eva-file-bbt.png)

<figcaption>If we had an Operating System character, he'd be sitting next to her.</figcaption>
</figure>

### What File Systems Do

Aside from knowing how to retrieve the content of a file from the disk it's
saved on, **file systems also maintain additional information about each
file.** For example, a file system might keep track of, among many other things,
when a file was created, when it was last accessed, or which user "owns" the
file.

However, **the most "popular" function of the file system is to maintain a
human-readable way to organize**–one might say, _file away_–**this data.** It
does this is by keeping track of the `path` of each file within a
system of `directories` (also called `folders`[^0]).

### Folders, directories, and paths

When file systems were first created, all files would appear in a single, long
list. However, as this proved unwieldy, people soon turned to the real world for
guidance. In particular, two metaphors surfaced:

#### The folder metaphor

<figure>
![TODO](./filing-away.png)

<figcaption>Filing away her fanfic collection.</figcaption>
</figure>

**Imagine each file as a sheet of paper. To keep related files together, you could
place them in a paper `folder` to collect them.** Then, you might imagine yourself
continuing to group related `file`s and `folder`s together, placing them within
their own `folder`, then within another `folder`, then maybe within yet another
`folder`... until eventually, thanks to your zelous organizing, you end up with
a single `folder` that contains all the `file`s and `folder`s in your system.

#### The directory metaphor

<figure>
![TODO](./directory.png)

<figcaption>"This filesystem is a maze!"</figcaption>
</figure>

Similarly, imagine you're searching for a file somewhere in your system. **To
find the data seek, you might consult a `directory` that lists every file along
with its "address" in the system.** As the amount of files grows big, you may
want to have a multi-level system, where each level has its own `directory` to
point you towards either the files at that level, or other directories where to
continue your search.

#### Finding your Path

Eventually, regardless of whether you imagine this organization system as
`folders` or `directories`, each file will have its own unique position within
it. That is, starting from the top-level `folder` (or `directory`) of your
system, commonly marked with "`/`", you will have to move down a sequence of
nested `folders` (or `directories`) until you find the file seek. **The `path`
of a file is the sequence of `folders` (or `directories`) that you must journey
through to reach it.**

While the general metaphor is the same, there are some unique differences
on how Windows and Unix[^0_5] systems represent paths. These are:

- **Top-level folder/directory:** in Windows, the top-level folder is prefixed
  with a single capital letter indicating the disk it belongs to. For example,
  you likely have seen `C://`, the top level folder of the `C` disk. In Unix,
  the top level folder is always `/`.
- **Path separator:** In Windows, each folder in a path is historically
  separated with a backward slash ("`\`"). Unix systems always use the forward
  slash ("`/`").

### The File System Tree

Regardless of which metaphor works best for you, the end result is the same type of structure, one
computer scientists everywhere love: a tree[^1].

<figure>
![TODO](./hierarchy.png)

<figcaption>
  If you rotate the picture 180 degrees, you can imagine the top level folder as the base of a tree (its "root"),
  while the branching paths form its, well, "branches" (that end in "leaves"). Yes, these are all
  technical terms.
</figcaption>
</figure>

Here's some more names you'll often hear about when talking about file systems:

- **Root:** The top-level folder, where it all starts from. In Unix systems (MacOS & Linux)
  this is called `/`. On windows, you often have multiple roots (for separate disks or disk
  partitions) each named with a letter. The most common name is `C:/`.
- **Parent:** Each folder (aside from the `root`) has a folder that contains it: this is its
  parent. Computer scientists generally call the elements within a parent its children, but this
  is not as popular in file systems.
- **Subdirectory/Subfolder:** If you put a `directory` within a `directory`, that's called a `subdirectory`
  of the parent `directory`. You can use a similar terminology for `folder`.

[Path diagram]

Do not talk to me or my subdirectory, or my subdirectory subdirectory, or my subdirectory ever again.

#### Your own personal space: Home Sweet Home (`~`)

<figure>
![TODO](./home-sweet-home.png)

<figcaption>He cross-stitched that himself.</figcaption>
</figure>

In modern operating systems, **each user is assigned a "home directory", their
own special folder where to store their data.** The home directory of a user is
usually inaccessible to other users, making it a safe place to collect personal
files.

**The symbol for the home directory is `~`**. You'll see it around a lot.

On Windows, the home is generally under `C:\Users\[username]`. On Unix
systems, the position changes quite a bit, but will generally be some variation of
`/usr/[username]`.

#### Sneaking around: hidden files and folders

To make things more tidy, or to hide them from less experienced eyes, files and folders can
be marked as hidden. In Unix systems, this is done by prefixing their name with a "`.`".
It is often used for configuration files (like `.env`) or program data
folders(like `.git/`).

## Moving across the file system, Terminal Edition

One of the first things to do to get comfortable with the terminal is to learn
to move around the filesystem. You only need to learn three simple commands to
make moving around a breeze:

1. "Where am I?" (`pwd`)
2. "What's here?" (`ls`)
3. "Let's go somewhere else" (`cd`)

Windows used to have its own unique commands, but it has adapted to the Unix style. If you're using PowerShell
(you should), then most of the Unix commands will be available to you[^2].

### Oh, user, where art thou? (`pwd`)

**The first, most important question is: where am I?** To answer this, you can
use the `pwd` command. `pwd` stands for **P**rint **W**orking **D**irectory, but
if you need another mnemonic I propose "**P**ardon, **W**hich **D**irectory (is
this)?"

Running `pwd` will show you the `path` you're currently at.

```bash
pwd
# output
/users/boba-tan/programming/blorbo-shrine/
```

### Show Me Your ~~Secrets~~ Files! (`ls`)

**You can look around your current position with the `ls` command.** `ls` stands for
**l**i**s**t, but if you need another mnemonic, I suggest "**L**et's **S**ee".

```bash
ls
# output
asdfkasdfhjk.png
doujin.zip
art/
memes/
```

One caveat about `ls` is that it doesn't show hidden files (the ones starting
with `.`) by default. While this keeps things tidy, you might want to see _everything_
your current position has to offer. You can do this with the `-a` flag, where `a` stands for "all".
You can do this by typing `ls -a`,

### Beam me anywhere, Scotty (`cd`)

**To go to a different place, you can use the `cd` command.** `cd` stands for **C**hange **D**irectory, and if you need a
different mnemonic you're out of luck cause I really can't do better than that.

You use `cd` by giving it the `path` you want to reach. For example, to move to your home folder, you could use:

```bash
cd ~
# equivalent to:
cd /usr/boba-tan
```

**`cd` can use both relative and absolute paths**. At this stage, however, you still don't know what this means,
so let's go learn that.

> Quick tip: you can use `cd -` to go back to where you were before your last directory change.

## A bit more about paths

Paths are used in many, many terminal commands (and beyond). While there isn't a lot to learn about paths,
there's still a little bit more to learn about.

### Absolute vs Relative Paths

When you want to point to a location, you have two ways to describe how to reach it:

- In an **absolute way,** by describing the `path` to take from an agreed-upon "origin"/stating point.
- In a **relative way,** by describing the `path` to take from where you currently are.

#### Working with absolute paths

**Absolute paths always start from the root of the file system.** This means that absolute path
always start with `/` or with `~` (which is a shorthand for `/usr/[username]`).

```bash
# go to the fanfics folder in the user home
cd ~/fanfics

# list all the users folders
ls /usr/
```

- Relative paths start from where you're at in the Terminal (the output of `pwd`). `.` is generally
  implied, but you'll often see `..`. This can be further combined, for example you can use `cd ../..`
  to go visit grandpa.

#### Working with relative paths

**Relative paths start from where you currently are in the file system.** Unless a path starts with `/`
or `~`, it is interpreted as relative.

Relative paths also have their own special symbols:

- `.` (single dot) indicates **your current directory**. `directory_name/`
  (without prefix) is equivalent to `./directory_name/`, that is the
  "`directory_name/`" directory under your current directory "`./`".
- `..` (double dot) indicates **the parent directory**. This shorthand can be
  used to go visit your whole family tree. For example, `../../` will be
  your grandparent directory, while `../another_directory` will allow you to point to your
  "sibling directory".

```bash
# go visit your parent
cd ..

# go see what your grandparent has to offer
ls ../..

# stay exactly where you are!!
cd .

# now show me your pockets
ls .
```

## Final diagram

Here's a final diagram that might help you orientate yourself.

There's a lot to say about file systems, but this is a good overview of all you might need to know
to start exploring them from a command line.

[^-1]:
    While there's a lot of different types of file systems (you might have heard of `FAT` or
    `NTFS`), their differences don't generally matter to most users, even programmers.

[^0]: Theoretically there's a difference, but practically there's not. Don't even worry about it.
[^0_5]: MacOS + Linux
[^1]: Two computer scientists sitting in a tree, [T-R-A-V-E-R-S-I-N-G](https://en.wikipedia.org/wiki/Tree_traversal)
[^2]: This is called `POSIX` compliance.

<style>{`
    img {
      padding-block: 0!important;
      border: 1px solid #bbb;
      width: calc(100% - 8px);
      max-width: 700px;
    }
    img + img {
      margin-top: 20px;
    }
    figure {
        text-align: center;
    }
    figcaption {
        margin-top: 5px;
        text-size: small;
        color: gray;
    }
    .whats-this, .socials-callout, .warning {
      font-family: var(--font-family-title);
      background-color: #f4f4f4;
      padding: 20px;
      margin-top: 40px;
    }
    .socials-callout h3 {
      margin: 0 0 10px 0;
      font-size: 20px;
    }
    .socials-callout img {
      margin-block: 20px;
      max-width: 600px;
    }
    .socials-callout ul {
      margin: 0;
      padding: 0 0 0 20px;
    }
    .socials-callout li {
      margin: 0 0 0 0;
    }
    .socials-callout summary {
      font-size: 16px;
      cursor: pointer;
    }
    div.socials-callout:last-of-type {
      margin-bottom: 50px;
    }
`}</style>
